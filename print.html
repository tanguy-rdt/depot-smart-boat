<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Smart Boat</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Aperçu général</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Fonctionnement des capteurs</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="sensor/bme280.html"><strong aria-hidden="true">2.1.</strong> Capteur de température, humidité et pression</a></li><li class="chapter-item expanded "><a href="sensor/bmm150.html"><strong aria-hidden="true">2.2.</strong> Boussole</a></li><li class="chapter-item expanded "><a href="sensor/mcp3008.html"><strong aria-hidden="true">2.3.</strong> Girouette</a></li><li class="chapter-item expanded "><a href="sensor/hcsr05.html"><strong aria-hidden="true">2.4.</strong> Capteur de profondeur</a></li></ol></li><li class="chapter-item expanded "><a href="sensor/pca9685.html"><strong aria-hidden="true">3.</strong> Le mouvement des voiles</a></li><li class="chapter-item expanded "><a href="arch.html"><strong aria-hidden="true">4.</strong> L'architecture du code</a></li><li class="chapter-item expanded "><a href="bt.html"><strong aria-hidden="true">5.</strong> Bluetooth</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Smart Boat</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tanguy-rdt/depot-smart-boat" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>Melvin DUBEE - Tanguy ROUDAUT</p>
<p><em>ENSTA Bretagne</em></p>
</blockquote>
<p>Ce projet met en ouvre un système intelligent intégrant une interface graphique basé sur <a href="https://github.com/emilk/egui"><em>egui</em></a> et une commande vocale pour le contrôle d'une maquette de bateau. Différent capteurs de naviguation et des moteurs permettent de simuler une naviguation en sécurité et assisté.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<h3 id="installation-de-rust"><a class="header" href="#installation-de-rust">Installation de rust</a></h3>
<p>Le code de ce projet est réalisé en rust, il est donc important de l'avoir installé.</p>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
</code></pre>
<h3 id="ajouter-votre-clé-daccès-picovoice"><a class="header" href="#ajouter-votre-clé-daccès-picovoice">Ajouter votre clé d'accès Picovoice</a></h3>
<p>Vous pouvez ajouter votre clé d'accès:</p>
<ul>
<li>De manière temporaire dans le terminal actif avec <code>export PICOVOICE_ACCES_KEY="YOUR_ACCES_KEY"</code></li>
<li>De manière permanente en ajoutant cette commande dans votre <code>~/.bashrc</code> ou <code>~/.zshrc</code> em fonction du shell utilisé.</li>
</ul>
<p><em>Si vous n'avez pas de clé d'accès vous pouvez en obtenir une en créant un compte sur le site de <a href="https://console.picovoice.ai/login">picovoice</a> gratuitement.</em></p>
<h3 id="sur-raspberryos"><a class="header" href="#sur-raspberryos">Sur RaspberryOS</a></h3>
<p>Cette commande marchera uniquement avec un Raspberry Pi ou un émulateur qui prend en charge les ports GPIO. Le mode sur cible prend en compte la crate rppal qui permet de contrôler les ports GPIO.</p>
<pre><code class="language-bash">$ cargo run --features=on_target
</code></pre>
<p>Actuellement l'interface graphique en WASM n'a pas était réalisé. Vous devez connecter un écran au Raspberry Pi ou utiliser un serveur VNC <em>(le serveur doit être activé avec la commande <code>sudo raspi-config</code> puis activer le serveur VNC dans le menu <code>Interface</code>).</em></p>
<h3 id="sur-un-os-différent-de-la-cible-mode-stub"><a class="header" href="#sur-un-os-différent-de-la-cible-mode-stub">Sur un OS différent de la cible <em>(Mode stub)</em></a></h3>
<p>Le mode <em>stub</em> vous permet d'éxecuter l'interface graphique avec une maquette simulé pour s'affranchire de capteurs et des GPIO. Cependant vous-devez quand même avoir enregistré votre clé d'accès Picovoice.</p>
<p>Cela est particulièrement utile pour réaliser des modifications sur l'interface graphique.</p>
<pre><code class="language-bash">$ cargo run 
</code></pre>
<h2 id="mots-détecté-avec-la-commande-vocale"><a class="header" href="#mots-détecté-avec-la-commande-vocale">Mots détecté avec la commande vocale</a></h2>
<ol>
<li>wake word: "Ok Bateau"</li>
<li>content:
<ul>
<li>"Tourne/va/allons à gauche/babord"</li>
<li>"Tourne/va/allons à droite/tribord"</li>
<li>"vent de près à gauche/babord"</li>
<li>"vent de près à droite/tribord"</li>
<li>"vent de face"</li>
<li>"vent arrière"</li>
<li>"vent largue à gauche/babord"</li>
<li>"vent largue à droite/tribord"</li>
<li>"vent de travers à gauche/babord"</li>
<li>"vent de travers à droite/tribord"</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capteur-de-température-humidité-et-pression"><a class="header" href="#capteur-de-température-humidité-et-pression">Capteur de température, humidité et pression</a></h1>
<p><img src="sensor/./img/weather.png" alt="" /></p>
<p>La page <em>Weather</em> de l'interface graphique permet d'avoir une prédiction météorologique incluant la température, la vitesse du vent ainsi que sa direction sur 5 jours. <br />
Grâce à un capteur i2c intégré au bateau, le <em>BME280</em>, une mesure en temps réel de la température, humidité et pression est également disponnible.</p>
<h2 id="configuration-du-bme280"><a class="header" href="#configuration-du-bme280">Configuration du BME280</a></h2>
<p>Avant de réaliser une lecture de donnée météorologique, il est nécessaire de configurer le capteur. On notera 3 registres:</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Adresse</th><th>Information</th></tr></thead><tbody>
<tr><td>HUM_CTRL</td><td><em>0xf2</em></td><td></td></tr>
<tr><td>MEAS_CTRL</td><td><em>0xf4</em></td><td></td></tr>
<tr><td>CONFIG</td><td><em>0xf5</em></td><td></td></tr>
</tbody></table>
</div>
<p>Dans notre cas nous avons décidé d'utiliser les valeurs suivantes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init(&amp;mut self, gpio: &amp;mut Gpio){
    gpio.i2c_set_slave_addr(BME280_ADDR);
    gpio.i2c_write_byte(HUM_CTRL_ADDR, 0x01);
    gpio.i2c_write_byte(CTRL_MEAS_ADDR, 0x27);
    gpio.i2c_write_byte(BME280_CONFIG_ADDR, 0x00);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lecture-de-la-température"><a class="header" href="#lecture-de-la-température">Lecture de la température</a></h2>
<p>Une fois que le capteur est configuré nous pouvons commencer par lire la température qui est une valeur sur 3 octets, il faut alors lire les registres suivants: <em>0xfa, 0xfb, 0xfc</em></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_temperature(&amp;mut self, gpio: &amp;mut Gpio) -&gt; f32{
    gpio.i2c_set_slave_addr(BME280_ADDR);
    let msb: u8 = gpio.i2c_read_byte_from(TEMP_ADDR[MSB]);    // 0xfa
    let lsb: u8 = gpio.i2c_read_byte_from(TEMP_ADDR[LSB]);    // 0xfb
    let xlsb: u8 = gpio.i2c_read_byte_from(TEMP_ADDR[XLSB]);  // 0xfc
    let temp_raw: i32 = ((msb as i32) &lt;&lt; 12) | ((lsb as i32) &lt;&lt; 4) | xlsb as i32;

    let temperature_in_C: f32 = (self.compensation_temperature(gpio, temp_raw)) as f32 / 100.0;

    temperature_in_C
}
<span class="boring">}</span></code></pre></pre>
<p>La valeure obtenue <em>temp_raw</em>, correspond à la température brute. Il faut compenser cette valeur à l'aide de constantes propres à chaque capteur qui sont ajusté en usine. <br />
Pour la température, les registres intéressant sont les suivantes:</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Adresse</th><th>n bits</th></tr></thead><tbody>
<tr><td>T1_ADDR</td><td><em>0x89, 0x88</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>T2_ADDR</td><td><em>0x8b, 0x8a</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>T3_ADDR</td><td><em>0x8d, 0x8c</em></td><td>2 * <em>u8</em></td></tr>
</tbody></table>
</div>
<p>Avec la fonction <code>compensation_temperature</code> on obtient alors la température en degrés celcius. Les fonctions de compensation sont donnée dans la documentation du BME280.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compensation_temperature(&amp;mut self, gpio: &amp;mut Gpio, temp_raw: i32) -&gt; i32 {
    let mut msb = gpio.i2c_read_byte_from(T1_ADDR[MSB]);
    let mut lsb = gpio.i2c_read_byte_from(T1_ADDR[LSB]);
    let dig_t1: u16 = ((msb as u16) &lt;&lt; 8) | lsb as u16;

    msb = gpio.i2c_read_byte_from(T2_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(T2_ADDR[LSB]);
    let dig_t2: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(T3_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(T3_ADDR[LSB]);
    let dig_t3: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    let var1  = ((((temp_raw &gt;&gt; 3) - ((dig_t1 as i32) &lt;&lt; 1))) * (dig_t2 as i32)) &gt;&gt; 11; 
    let var2  = ((((temp_raw &gt;&gt; 4) - (dig_t1 as i32)) * ((temp_raw &gt;&gt; 4) - ((dig_t1 as i32))) &gt;&gt; 12) * (dig_t3 as i32)) &gt;&gt; 14;
    self.t_fine = var1 + var2;
    let temp = (self.t_fine * 5 + 128) &gt;&gt; 8;

    temp
}
<span class="boring">}</span></code></pre></pre>
<p>Nous pouvons maintenant réaliser la lecture de la pression et de l'humidité qui se décompose de la même manière.</p>
<h2 id="lecture-de-la-pression"><a class="header" href="#lecture-de-la-pression">Lecture de la pression</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Adresse</th><th>n bits</th></tr></thead><tbody>
<tr><td>PRESS_ADDR</td><td><em>0xf7, 0xf8, 0xf9</em></td><td>3 * <em>u8</em></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>P1_ADDR</td><td><em>0x8f, 0x8e</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P2_ADDR</td><td><em>0x91, 0x90</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P3_ADDR</td><td><em>0x93, 0x92</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P4_ADDR</td><td><em>0x95, 0x94</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P5_ADDR</td><td><em>0x97, 0x96</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P6_ADDR</td><td><em>0x99, 0x98</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P7_ADDR</td><td><em>0x9b, 0x9a</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P8_ADDR</td><td><em>0x9d, 0x9c</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>P9_ADDR</td><td><em>0x9f, 0x9e</em></td><td>2 * <em>u8</em></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_pressure(&amp;mut self, gpio: &amp;mut Gpio) -&gt; f32{
    gpio.i2c_set_slave_addr(BME280_ADDR);
    let msb: u8 = gpio.i2c_read_byte_from(PRESS_ADDR[MSB]);
    let lsb: u8 = gpio.i2c_read_byte_from(PRESS_ADDR[LSB]);
    let xlsb: u8 = gpio.i2c_read_byte_from(PRESS_ADDR[XLSB]);
    let press_raw: i32 = ((msb as i32) &lt;&lt; 12) | ((lsb as i32) &lt;&lt; 4) | xlsb as i32;

    let pressure_in_pa = (self.compensation_pressure(gpio, press_raw) as f32)/256.0;

    pressure_in_pa
}

fn compensation_pressure(&amp;self, gpio: &amp;Gpio, press_raw: i32) -&gt; u32{
    let mut msb = gpio.i2c_read_byte_from(P1_ADDR[MSB]);
    let mut lsb = gpio.i2c_read_byte_from(P1_ADDR[LSB]);
    let dig_p1: u16 = ((msb as u16) &lt;&lt; 8) | lsb as u16;

    msb = gpio.i2c_read_byte_from(P2_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P2_ADDR[LSB]);
    let dig_p2: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P3_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P3_ADDR[LSB]);
    let dig_p3: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P4_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P4_ADDR[LSB]);
    let dig_p4: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P5_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P5_ADDR[LSB]);
    let dig_p5: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P6_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P6_ADDR[LSB]);
    let dig_p6: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P7_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P7_ADDR[LSB]);
    let dig_p7: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P8_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P8_ADDR[LSB]);
    let dig_p8: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    msb = gpio.i2c_read_byte_from(P9_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(P9_ADDR[LSB]);
    let dig_p9: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;



    let mut var1: i64 = (self.t_fine as i64) - 128000;
    let mut var2: i64 = var1 * var1 * (dig_p6 as i64);
    var2 = var2 + ((var1 * (dig_p5 as i64)) &lt;&lt; 17);
    var2 = var2 + ((dig_p4 as i64) &lt;&lt; 35);
    var1 = ((var1 * var1 * (dig_p3 as i64)) &gt;&gt; 8) + ((var1 * (dig_p2 as i64)) &lt;&lt; 12);
    var1 = ((((1 as i64) &lt;&lt; 47) + var1)) * (dig_p1 as i64) &gt;&gt; 33;

    if var1 == 0 {
        return 0;
    }

    let mut p: i64 = 1048576 - (press_raw as i64);
    p = (((p &lt;&lt; 31) - var2)*3125)/var1;
    var1 = ((dig_p9 as i64) * (p&gt;&gt;13) * (p&gt;&gt;13)) &gt;&gt; 25;
    var2 = ((dig_p8 as i64) * p) &gt;&gt; 19;
    p = ((p + var1 + var2) &gt;&gt; 8) + ((dig_p7 as i64)&lt;&lt;4);

    let pressure: u32 = (p as u32)/100;

    pressure
}
<span class="boring">}</span></code></pre></pre>
<h2 id="lecture-de-lhumidité"><a class="header" href="#lecture-de-lhumidité">Lecture de l'humidité</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Adresse</th><th>n bits</th></tr></thead><tbody>
<tr><td>PRESS_ADDR</td><td><em>0xfd, 0xfe</em></td><td>2 * <em>u8</em></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>H1_ADDR</td><td><em>0xa1</em></td><td>1 * <em>u8</em></td></tr>
<tr><td>H2_ADDR</td><td><em>0xe2, 0xe1</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>H3_ADDR</td><td><em>0xe3</em></td><td>1 * <em>u8</em></td></tr>
<tr><td>H4_ADDR</td><td><em>0xe4, 0xe5</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>H5_ADDR</td><td><em>0xe6, 0xe5</em></td><td>2 * <em>u8</em></td></tr>
<tr><td>H6_ADDR</td><td><em>0xe7</em></td><td>1 * <em>u8</em></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_humidity(&amp;mut self, gpio: &amp;mut Gpio) -&gt; f32{
    gpio.i2c_set_slave_addr(BME280_ADDR);
    let msb: u8 = gpio.i2c_read_byte_from(HUM_ADDR[MSB]);
    let lsb: u8 = gpio.i2c_read_byte_from(HUM_ADDR[LSB]);
    let hum_raw: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    let hum_in_percent = (self.compensation_humidity(gpio, hum_raw as i32) as f32)/1024.0;

    hum_in_percent
}

fn compensation_humidity(&amp;self, gpio: &amp;Gpio, hum_raw: i32) -&gt; i32{
    let dig_h1: u8 = gpio.i2c_read_byte_from(H1_ADDR);

    let mut msb = gpio.i2c_read_byte_from(H2_ADDR[MSB]);
    let mut lsb = gpio.i2c_read_byte_from(H2_ADDR[LSB]);
    let dig_h2: i16 = (((msb as u16) &lt;&lt; 8) | lsb as u16) as i16;

    let dig_h3: u8 = gpio.i2c_read_byte_from(H3_ADDR);

    msb = gpio.i2c_read_byte_from(H4_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(H4_ADDR[LSB]);
    let dig_h4: i16 = (((msb as u16) &lt;&lt; 4) | ((lsb &amp; 0x0f) as u16)) as i16;

    msb = gpio.i2c_read_byte_from(H5_ADDR[MSB]);
    lsb = gpio.i2c_read_byte_from(H5_ADDR[LSB]);
    let dig_h5: i16 = (((msb as u16) &lt;&lt; 4) | (((lsb &gt;&gt; 4) &amp; 0x0f) as u16)) as i16;

    let dig_h6: i8 = gpio.i2c_read_byte_from(H6_ADDR) as i8;

    let mut v_x1: i32 = self.t_fine - (76800 as i32);
    v_x1 = ((((hum_raw &lt;&lt; 14) -((dig_h4 as i32) &lt;&lt; 20) - ((dig_h5 as i32) * v_x1)) + (16384 as i32)) &gt;&gt; 15) * (((((((v_x1 * (dig_h6 as i32)) &gt;&gt; 10) *
            (((v_x1 * (dig_h3 as i32)) &gt;&gt; 11) + (32768 as i32))) &gt;&gt; 10) + (2097152 as i32)) * (dig_h2 as i32) + 8192) &gt;&gt; 14);
    v_x1 = v_x1 - (((((v_x1 &gt;&gt; 15) * (v_x1 &gt;&gt; 15)) &gt;&gt; 7) * (dig_h1 as i32)) &gt;&gt; 4);
    v_x1 = v_x1.clamp(0, 419430400);
    let hum: i32 =  ((v_x1 &gt;&gt; 12)) as i32;

    hum
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boussole"><a class="header" href="#boussole">Boussole</a></h1>
<p><img src="sensor/./img/main.png" alt="" /></p>
<p>La page principal permet de controler le bateau et d'avoir différente informations. Nous allons commencé par l'aiguille blanche présente sur le cadran qui reprèsente la boussole. <br />
Grâce à un capteur i2c intégré au bateau, le <em>BMM150</em>, une mesure en temps réel de la position par rapport au nord est disponnible.</p>
<h2 id="configuration-du-bmm150"><a class="header" href="#configuration-du-bmm150">Configuration du BMM150</a></h2>
<p>Dans un premier temps il est nécessaire de réaliser une configuration du capteur comme pour le <em>BME280</em>.</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Adresse</th><th>Information</th></tr></thead><tbody>
<tr><td>CTRL_POWER_REGISTER</td><td><em>0x4b</em></td><td>Permet de configurer le mode d'allimentation</td></tr>
<tr><td>MODE_RATE_REGISTER</td><td><em>0x4c</em></td><td>Permet de configurer la fréquence de fonctionnement</td></tr>
<tr><td>REG_REP_XY</td><td><em>0x51</em></td><td>Permet de configurer la précison des axes X et Y</td></tr>
<tr><td>REG_REP_Z</td><td><em>0x52</em></td><td>Permet de configurer la précision de l'axe Z</td></tr>
<tr><td>REG_AXES_ENABLE</td><td><em>0x4e</em></td><td>Permet d'activer ou de désactiver les axes souhaités</td></tr>
</tbody></table>
</div>
<p>Dans notre cas nous allons utiliser la configuration suivante:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init(&amp;mut self, gpio: &amp;mut Gpio){
    self.set_power_bit(ENABLE_POWER, gpio);
    thread::sleep(Duration::from_millis(3)); 
    let chip_id = self.get_chip_id(gpio);
    if chip_id == CHIP_ID_VALUE {
        println!("bmm150 init sucess");
        self.get_trim_value(gpio);
        self.set_operation_mode(POWERMODE_NORMAL, gpio);
        self.set_preset_mode(PRESETMODE_HIGHACCURACY, gpio);
        self.set_rate(RATE_10HZ, gpio);
        self.set_measurement_xyz(true, true, true, gpio);
    }
    else {
        println!("bmm150 init fail");
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Les différentes fonctions de configuration sont disponnible dans le fichier <a href="https://github.com/tanguy-rdt/depot-smart-boat/blob/main/src/boat_control/bmm150.rs"><em>bmm150.rs</em></a> de notre dépot.</p>
<h2 id="lecture-des-paramètres-de-compensation"><a class="header" href="#lecture-des-paramètres-de-compensation">Lecture des paramètres de compensation</a></h2>
<p>Le <em>BMM150</em> est un capteur bosch, comme pour le <em>BME280</em>. Le principe de fonctionnement est le même, les valeurs lus dans les registres sont des données brut. Il faut donc les compensés.</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Adresse</th><th>n bits</th></tr></thead><tbody>
<tr><td>DIG_X1</td><td><em>0x5D</em></td><td>1 * <em>u8</em></td></tr>
<tr><td>DIG_Z4_LSB</td><td><em>0x62</em></td><td>1 * <em>u8</em></td></tr>
<tr><td>DIG_Z2_LSB</td><td><em>0x68</em></td><td>1 * <em>u8</em></td></tr>
</tbody></table>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_trim_value(&amp;mut self, gpio: &amp;mut Gpio) {
    gpio.i2c_set_slave_addr(BMM150_ADDR);

    let mut trim_x1_y1 = [0u8; 2];
    gpio.i2c_read_bytes_from(DIG_X1, &amp;mut trim_x1_y1);

    let mut trim_xyz_data = [0u8; 4];
    gpio.i2c_read_bytes_from(DIG_Z4_LSB, &amp;mut trim_xyz_data);

    let mut trim_xy1_xy2 = [0u8; 10];
    gpio.i2c_read_bytes_from(DIG_Z2_LSB, &amp;mut trim_xy1_xy2);

    self.trim_data.dig_x1 = trim_x1_y1[0] as i8;
    self.trim_data.dig_y1 = trim_x1_y1[1] as i8;
    self.trim_data.dig_x2 = trim_xyz_data[2] as i8;
    self.trim_data.dig_y2 = trim_xyz_data[3] as i8;
    let temp_msb: u16 = (trim_xy1_xy2[3] as u16) &lt;&lt; 8;
    self.trim_data.dig_z1 = temp_msb | trim_xy1_xy2[2] as u16;
    let temp_msb: u16 = (trim_xy1_xy2[1] as u16) &lt;&lt; 8;
    self.trim_data.dig_z2 = (temp_msb | trim_xy1_xy2[0] as u16) as i16;
    let temp_msb: u16 = (trim_xy1_xy2[7] as u16) &lt;&lt; 8;
    self.trim_data.dig_z3 = (temp_msb | trim_xy1_xy2[6] as u16) as i16;
    let temp_msb: u16 = (trim_xyz_data[1] as u16) &lt;&lt; 8;
    self.trim_data.dig_z4 = (temp_msb | trim_xyz_data[0] as u16) as i16;
    self.trim_data.dig_xy1 = trim_xy1_xy2[9];
    self.trim_data.dig_xy2 = trim_xy1_xy2[8] as i8;
    let temp_msb: u16 = ((trim_xy1_xy2[5] &amp; 0x7F) as u16) &lt;&lt; 8;
    self.trim_data.dig_xyz1 = temp_msb | trim_xy1_xy2[4] as u16;
}
<span class="boring">}</span></code></pre></pre>
<p>C'est valeure ne change pas, il suffit de les lires une fois et de les utiliser au moment de la compensation.</p>
<h2 id="lecture-des-axes-et-compensations"><a class="header" href="#lecture-des-axes-et-compensations">Lecture des axes et compensations</a></h2>
<p>La lecture des axes peut être faite en une seule fois puisque les registres ce suivent, le premier registre à lire le <em>REG_DATA_X_LSB</em> correspond à l'adresse <em>0x42</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_geomagnetic(&amp;mut self, gpio: &amp;mut Gpio) -&gt; (i16, i16, i16){
    gpio.i2c_set_slave_addr(BMM150_ADDR);

    let mut rslt = [0u8; 8];
    gpio.i2c_read_bytes_from(REG_DATA_X_LSB, &amp;mut rslt);

    let reg_data = (rslt[0] &amp; 0xF8) &gt;&gt; 3;
    let msb_data = ((rslt[1] as i8) as i16) * 32;
    let geomagnetic_raw_x = msb_data | reg_data as i16;

    let reg_data = (rslt[2] &amp; 0xF8) &gt;&gt; 3;
    let msb_data = ((rslt[3] as i8) as i16) * 32;
    let geomagnetic_raw_y = msb_data | reg_data as i16;

    let reg_data = (rslt[4] &amp; 0xFE) &gt;&gt; 1;
    let msb_data = ((rslt[5] as i8) as i16) * 128;
    let geomagnetic_raw_z = msb_data | reg_data as i16;

    let reg_data = (rslt[6] &amp; 0xFC) &gt;&gt; 2;
    let msb_data = (rslt[7] as u16) &lt;&lt; 6;
    let geomagnetic_raw_r = msb_data | reg_data as u16;

    self.geomagnetic_x = self.compensate_x(geomagnetic_raw_x, geomagnetic_raw_r);
    self.geomagnetic_y = self.compensate_y(geomagnetic_raw_y, geomagnetic_raw_r);
    self.geomagnetic_z = self.compensate_z(geomagnetic_raw_z, geomagnetic_raw_r);

    (self.geomagnetic_x, self.geomagnetic_y, self.geomagnetic_z)
}
<span class="boring">}</span></code></pre></pre>
<p>On peut ensuite compenser c'est valeurs grâce aux constantes obtenus précédement et aux fonctions données dans la datasheet.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compensate_x(&amp;self, x: i16, r: u16) -&gt; i16{ 
    if x != -4096{
        let process_comp_x0: u16 = if r != 0 { r }
        else if self.trim_data.dig_xyz1 != 0 { self.trim_data.dig_xyz1 }
        else { 0 };

        if process_comp_x0 != 0 {
            let process_comp_x1: i32 = ((self.trim_data.dig_xyz1 as i32)*16384)/process_comp_x0 as i32;
            let process_comp_x2: i32 = (process_comp_x1 as i32) - 0x4000;
            let mut retval: i32 = process_comp_x2;
            let process_comp_x3: i32 = retval * retval;
            let process_comp_x4: i32 = (self.trim_data.dig_xy2 as i32) * (process_comp_x3/128);
            let process_comp_x5: i32 = ((self.trim_data.dig_xy1 as i16) * 128) as i32;
            let process_comp_x6: i32 = (retval) * process_comp_x5;
            let process_comp_x7: i32 = (process_comp_x4 + process_comp_x6)/512 + (0x100000 as i32);
            let process_comp_x8: i32 = ((self.trim_data.dig_x2 as i16) + (0xA0 as i16)) as i32;
            let process_comp_x9: i32 = (process_comp_x7 * process_comp_x8)/4096;
            let process_comp_x10: i32 = (x as i32) * process_comp_x9;
            retval = process_comp_x10/8192;
            retval = (retval + (self.trim_data.dig_x1 as i32) * 8) / 16;
            retval as i16
        }
        else {
            -32768
        }
    }
    else {
        -32768
    }
}

fn compensate_y(&amp;self, y: i16, r: u16) -&gt; i16{ 
    if y != -4096{
        let process_comp_y0: u16 = if r != 0 { r }
        else if self.trim_data.dig_xyz1 != 0 { self.trim_data.dig_xyz1 }
        else { 0 };

        if process_comp_y0 != 0 {
            let process_comp_y1: i32 = (self.trim_data.dig_xyz1 as i32)*16384/process_comp_y0 as i32;
            let process_comp_y2_temp: i32 = process_comp_y1 as i32 - 0x4000;
            let process_comp_y2: u16 = if process_comp_y2_temp &lt; 0 { 0 } else { process_comp_y2_temp as u16 };                
            let mut retval: i16 = process_comp_y2 as i16;
            let process_comp_y3: i32 = (retval as i32) * (retval as i32);
            let process_comp_y4: i32 = self.trim_data.dig_xy2 as i32 * (process_comp_y3/128);
            let process_comp_y5: i32 = ((self.trim_data.dig_xy1 as i16) * 128) as i32;
            let process_comp_y6: i32 = (process_comp_y4 + (retval as i32) * process_comp_y5)/512;
            let process_comp_y7: i32 = ((self.trim_data.dig_y2 as i16) + (0xA0 as i16)) as i32;
            let process_comp_y8: i32 = ((process_comp_y6 + 0x100000)*process_comp_y7)/4096;
            let process_comp_y9: i32 = (y as i32)*process_comp_y8;
            retval = (process_comp_y9 / 8192) as i16;
            retval = (retval + ((self.trim_data.dig_y1 as i16) * 8))/16;
            retval
        }
        else {
            -32768
        }
    }
    else {
        -32768
    }
}

fn compensate_z(&amp;self, z: i16, r: u16) -&gt; i16{ 
    if z != -16384{
        if self.trim_data.dig_z2 != 0 &amp;&amp; self.trim_data.dig_z1 != 0 &amp;&amp; self.trim_data.dig_xyz1 != 0 &amp;&amp; r != 0 {
            let process_comp_z0: i16 = (r as i16) - (self.trim_data.dig_xyz1 as i16);
            let process_comp_z1: i32 = (((self.trim_data.dig_z3 as i32) * (process_comp_z0 as i32)))/4;
            let process_comp_z2: i32 = ((z - self.trim_data.dig_z4) as i32)*32768;
            let process_comp_z3: i32 = (self.trim_data.dig_z1 as i32) * ((r as i32) * 2); 
            let process_comp_z4: i16 = ((process_comp_z3+32768)/65536) as i16;
            let mut retval: i32 = (process_comp_z2 - process_comp_z1)/((self.trim_data.dig_z2 as i32)+(process_comp_z4 as i32));
            retval = retval.clamp(-32767, 32767);
            retval = retval/16;
            retval as i16
        }
        else {
            -32768
        }
    }
    else {
        -32768
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conversion-des-coordonnées-xyz-en-degrés-par-rapport-au-nord"><a class="header" href="#conversion-des-coordonnées-xyz-en-degrés-par-rapport-au-nord">Conversion des coordonnées XYZ en degrés par rapport au nord</a></h2>
<p>La conversion est simple puisqu'il s'agit d'appliquer des formules trigonomètriques et de s'assurer que la valeur obtenus reste entre 0 et 360 degrès.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_boat_direction_degree(&amp;mut self) -&gt; f32{
    let (x, y, z) = self.bmm150.get_geomagnetic(&amp;mut self.gpio);
    let mut compass = (x as f32).atan2(y as f32);
    if compass &lt; 0.0 { compass += 2.0 * std::f32::consts::PI; }
    if compass &gt; (2.0 * std::f32::consts::PI) { compass -= 2.0 * std::f32::consts::PI; }
    compass = (compass * 180.0 / std::f32::consts::PI) -70.0;
    format!("{:.2}", compass).parse().unwrap()
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="girouette"><a class="header" href="#girouette">Girouette</a></h1>
<p><img src="sensor/./img/main.png" alt="" /></p>
<p>La page principal permet de controler le bateau et d'avoir différente informations comme la boussole qui a était vu précédement. Sur le cadran ont peut voir une seconde aiguille, qui est bleu cette fois-ci, elle correspond à la direction du vent.
Nous avons pas pus intégrer ou réaliser une vrais girouette par manque de temps, d'argent et de place. Nous avons décidé de simuler cette fonctionnalité avec un potentiomètre qu'on tourne manuellement pour simuler l'automation du cap par exemple.</p>
<p>Le raspberry pi, n'intègre pas directement de port analogique. Nous avons utiliser un convertisseur analogique numérique, cette page concèrne d'avantage l'utilisation d'un tel convertisseur plustôt qu'une veritable girouette.</p>
<h2 id="lecture-dun-canal-dun-adc"><a class="header" href="#lecture-dun-canal-dun-adc">Lecture d'un canal d'un ADC</a></h2>
<p>Nous avons choisis l'ADC <em>MCP3008</em>, ce dernier possède 8 channel et une résolution de 10 bits, ce qui est plus que suffisant pour notre utilisations.</p>
<p>La lecture est simple et se fait en SPI.</p>
<div class="table-wrapper"><table><thead><tr><th>CMD</th><th>Start</th><th>SGL (0) - DIFF (1)</th><th>D2</th><th>D1</th><th>D0</th><th>ND</th><th>ND</th><th>ND</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>La première commande permet l'initialisation de la communication. La seconde une lecture en mode single sur le channel 0 et la dernière c'est une commande tampon pour laisser le temps à l'ADC de répondre. <br />
En rust, nous pouvons réaliser c'est commande comme l'exemple ci-dessous.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_raw_value(&amp;self, gpio: &amp;mut Gpio) -&gt; u16 {
    let send_buf = [0b00000001, 0b10000000, 0b00000000];
    let mut recv_buf = [0u8; 3];
    gpio.spi_transfer(&amp;mut recv_buf, &amp;send_buf);
    ((recv_buf[1] as u16) &lt;&lt; 8 | (recv_buf[2] as u16)) &amp; 0x3FF
}
<span class="boring">}</span></code></pre></pre>
<p>Cette fonction retourne une valeure entre 0 et 1023, il faut donc la convertir en degrès et la compenser par rapport au nord grâce à la boussole. Notre girouette est sur le bateau, il est alors nécessaire de la compenser pour obtenir une valeure cohérente.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compensate_raw_value(&amp;self, raw_value: u16, degrees_from_north: f32) -&gt; f32 {
        let value_in_degrees = ((raw_value as f32) * 360.0)/1023.0;
        value_in_degrees + degrees_from_north
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capteur-de-profondeur"><a class="header" href="#capteur-de-profondeur">Capteur de profondeur</a></h1>
<p><img src="sensor/./img/main.png" alt="" /></p>
<p>Encore une fois nous nous retrouvons sur l'écran principale. <br />
Cette fois-ci pour une simulation d'un sonar réalisé a l'aide d'un capteur ultrason, le <em>HC-SR05</em>.</p>
<h2 id="fonctionnement-du-hc-sr05"><a class="header" href="#fonctionnement-du-hc-sr05">Fonctionnement du HC-SR05</a></h2>
<p>Ici, aucune configuration est nécessaire. Nous allons émettre une onde que nous pouvons métaphoriquement imaginé à l'aide d'un 1 boolèen. Pour déterminer la distance par rapport au profondeur, nous allons mesurer le temps mis par l'onde pour revenir vers le récepteur. <br />
Seul les gpio sont utilisés, on emet une impulsion et on la recois, la distance est ensuite calculé en fonction de la différence de temps et la vitesse du son. <br />
L'implémentation en rust donne le code suivant.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_value(&amp;self, gpio: &amp;mut Gpio) -&gt; f64 {
    gpio.set_high(self.trigger_pin);
    thread::sleep(Duration::from_micros(10));
    gpio.set_low(self.trigger_pin);

    while gpio.is_low(self.echo_pin) {}
    let start = std::time::Instant::now();

    while gpio.is_high(self.echo_pin) {}
    let duration = start.elapsed();

    duration.as_secs_f64() * 340.0 / 2.0 * 100.0
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="le-mouvement-des-voiles"><a class="header" href="#le-mouvement-des-voiles">Le mouvement des voiles</a></h1>
<p>Sur notre maquette nous déplacons les voiles à l'aide de poulis imprimés en 3D et de moteurs <em>FT90MR</em>. Allimenter 4 moteurs grâce au Raspberry Pi peut être insuffisant, c'est pourquoi nous utilisons un contrôleur PWM externe, la carte <em>PCA9685</em>. <br />
Cette carte de commande fonctionne en i2c, nous pouvons associés deux avantages à cette carte. Le premier et que nous pouvons ajouté une allimentation supplémentaire ce qui évite une sollicitation trop importante du raspberry pi. De plus, nous pouvons contrôller 16 moteurs ou autre actionneur utilisant une commande PWM tout en limitant l'usage des ports GPIO.</p>
<p><img src="sensor/./img/main.png" alt="" /></p>
<p>Le contrôle des moteurs se fait également sur l'écran d'accueil. grâce aux différent slider.</p>
<h2 id="configuration-du-pca9685"><a class="header" href="#configuration-du-pca9685">Configuration du PCA9685</a></h2>
<p>La seul configuration nécessaire est le <em>prescaler</em> via le registre <em>0xfe</em>. <br />
Il est également possible, mais optionel, de configuré le PCA dans une mode particulier. Dans notre cas nous avons décidé d'activer le mode iterratif, <em>MODE_AI</em>. Ce mode permet d'écrire dans plusieurs registre à la suite. Par exemple, si l'on souhaite écrire <em>0x00</em> puis <em>0x01</em> à partir du registre <em>0xa0</em>, alors le PCA va comprendre qu'il faut écrire <em>0x00</em> sur <em>0xa0</em> puis <em>0x01</em> sur <em>0xa1</em>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn init(&amp;mut self, gpio: &amp;mut Gpio){
    gpio.i2c_set_slave_addr(PCA9685_I2C_ADDRESS);
    self.init_prescaler(gpio, SERVO_FREQ);
}

fn init_prescaler(&amp;mut self, gpio: &amp;mut Gpio, frequency: f32){
    // Calcule le prescaler nécessaire pour atteindre la fréquence PWM souhaitée
    let mut prescale_value = (((FREQUENCY_OSCILLATOR / (4096.0 * frequency)) + 0.5) - 1.0) as u8;
    
    if prescale_value &lt; PRESCALE_MIN {
        prescale_value = PRESCALE_MIN;
    }
    else if prescale_value &gt; PRESCALE_MAX {
        prescale_value = PRESCALE_MAX;
    }

    gpio.i2c_write_byte(PCA9685_MODE1, MODE1_SLEEP); 
    let _ = self.read_mode1(gpio);
    gpio.i2c_write_byte(PCA9685_PRESCALE, prescale_value); // set prescaler PWM hz to 50 (0x7a)
    thread::sleep(Duration::from_millis(5)); 

    gpio.i2c_write_byte(PCA9685_MODE1, MODE1_RESTART | MODE1_AI); 
    let _ = self.read_mode1(gpio); 
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
